\documentclass{report}

\begin{document}

\title{Diamond Game Report}
\author{Aastha Deshwal}
\date{\today}

\maketitle

\begin{abstract}
This report details the interaction with a generative AI (genAI) called Gemini to develop a strategy for the trick-taking card game "Diamonds." The objective was to create an optimized Diamonds game simulation code in Python, which reduces the chance of losing the game.
\end{abstract}

\section{Introduction/Objective}

The below report outlines the interaction with the generative AI (genAI) called Gemini, which is put to use while developing a strategy for the trick-taking card game "Diamonds." The objective was to generate an optimized Diamonds game simulation code in Python, which reduces the chance of losing the game.

\section{Methodology}

The development process involved the following steps:

1. Define Game Rules: We began by establishing a clear understanding of the Diamonds game rules, including bidding, playing tricks, and scoring. This ensured a common platform among humans and AI to share the concept.

2. Develop Strategies: We discussed potential strategies for bidding and card selection with Gemini. The primary focus was on minimizing the possibility of losing hands, particularly in scenarios where the risk of losing is not necessarily high. A crucial piece of information would be shared about possible strategies; Gemini would be able to create, while we will continue to prompt him to generate an optimal code for the Diamonds simulation game.

3. Code Generation & Optimization: Once we had the strategy, the code was generated by Gemini in Python code to simulate the Diamonds game. Further refinements were carried out in the code for better readability and optimality. After this step, we discussed some test cases in order to simulate the Diamonds game and check the simulation code.

\section{Reflection on Conversation with genAI & Learnings}

Communicating with Gemini was fruitful and afforded an opportunity to refine the approach in developing the Diamonds game simulation code. Below are some of the highlights that I experienced during our interaction:\newline
* Importance of Clear Communication: A clear definition of the game rules ensured the AI concentrated on its mission. \newline
* Exploring Different Strategies: Discussing different strategies with Gemini opened our minds to other strategies.\newline
* Leveraging AI Capabilities: This capability of Gemini in generating and optimizing the code significantly sped up development.\newline

\section{Reflections on Code That Was Generated/Snippets}

The diamonds-game code is well-structured in terms of the simulation process. Here are some of the key points regarding the code:\newline
* Card and Suit Definitions: Defining card suits and ranks with brief formulations makes the code readable.\newline
* Card Comparison Overloading: Overloading the ">" operator makes card comparison in terms of rank and trump easier during trick evaluation.\newline
* Bidding Strategy: The bidding strategy considers high cards and balanced suits, leading to more strategic bids.\newline
* Playing Cards Strategy: The card selection prioritizes Diamonds and high cards within playable suits, enhancing the strategic depth of gameplay.\newline

Snippet code below for the optimized comparison of cards:\newline

python\newline
import random\newline

# Card and Suit definitions (more concise)\newline
SUITS = "hearts diamonds clubs spades".split()\newline
RANKS = "A K Q J 10 9 8 7 6 5 4 3 2".split()\newline


class Card:\newline
    def __init__(self, suit, rank):\newline
        self.suit = suit\newline
        self.rank = rank\newline

    def __gt__(self, other):\newline
        # Overloading ">" operator for card comparison based on rank and trump\newline
        suit_values = {"hearts": 0, "diamonds": 1, "clubs": 2, "spades": 3}\newline
        return (\newline
            suit_values[self.suit], RANKS.index(self.rank)\newline
        ) > (suit_values[other.suit], RANKS.index(other.rank))\newline


class Deck:\newline
    def __init__(self):\newline
        self.cards = [Card(suit, rank) for suit in SUITS for rank in RANKS]\newline

    def shuffle(self):\newline
        random.shuffle(self.cards)\newline

    def deal(self, num_players, cards_per_player):\newline
        hands = [[] for _ in range(num_players)]\newline
        for _ in range(cards_per_player):\newline
            for player in range(num_players):\newline
                hands[player].append(self.cards.pop())\newline
        return hands\newline


def get_bid(hand):\newline
    # Improved bidding strategy: considers high cards and balanced suits\newline
    high_cards = sum(rank in ("A", "K", "Q", "J") for card in hand)\newline
    suit_counts = {suit: 0 for suit in SUITS}\newline
    for card in hand:\newline
        suit_counts[card.suit] += 1\newline
    balanced_suit_bonus = sum(count >= 3 for count in suit_counts.values())\newline
    return min(high_cards + balanced_suit_bonus, 7)\newline


def play_card(hand, led_suit):\newline
    # More strategic card selection: prioritize Diamonds and high cards\newline
    best_card = max(\newline
        card\newline
        for card in hand\newline
        if (card.suit == led_suit or card.suit == "diamonds")\newline
        and card not in hand\newline
    )\newline
    if not best_card:  # No playable suit or Diamonds, play the highest card\newline
        best_card = max(hand)\newline
    return best_card\newline


def evaluate_trick(played_cards):\newline
    # Use max function with custom comparison for winner determination\newline
    return max(played_cards)\newline


def calculate_points(bid, tricks_won):\newline
    return bid * 10 + max(0, tricks_won - bid)\newline


def play_game(num_players):\newline
    deck = Deck()\newline
    deck.shuffle()\newline
    hands = deck.deal(num_players, 13)\newline

    # Get bids from each player\newline
    bids = [get_bid(hand) for hand in hands]\newline

    # Play each trick\newline
    tricks = []\newline
    for _ in range(13):\newline
        led_suit = hands[0][0].suit\newline
        played_cards = [player.hand.pop(0) for player in hands]\newline
        winner = evaluate_trick(played_cards)\newline
        tricks.append((led_suit, winner.suit, winner.rank))\newline

        # Reorder players based on who won the trick\newline
        winning_index = played_cards.index(winner)\newline
        hands = hands[winning_index:] + hands[:winning_index]\newline

    # Calculate points for each player\newline
    for i, hand in enumerate(hands):\newline
        tricks_won = sum(trick[1] == bids[i] for trick in tricks)\newline
        points = calculate_points(bids[i], tricks_won)\newline
        print(f"Player {i+1} Points: {points}")\newline


\section{Conclusion & Path Forward}

Developing a functional and strategic Diamonds game simulation code with the assistance of Gemini worked. Further dimensions of improvement that we would like to aim at are:

Advanced Strategies: The creation of more complicated strategies, like underbidding or making sacrifices to win the later game.
AI Opponent: Creating an AI opponent of varying levels of skill with which to test the effectiveness of the code with regard to various levels of playing.
GUI: The creation of a graphical user interface for the Diamonds game simulation, allowing the players to have a direct view and interaction with the code.
These improvements should provide a much more robust and flexible tool that can be used to make any sort of Diamonds simulation.

\end{document}
